use core::fmt;

use crate::BranchCondition;

#[derive(Debug, Clone, Copy)]
pub enum SimdMnemonic {
    uzp1,
    uzp2,
    trn1,
    trn2,
    zip1,
    zip2,

    tbl,
    tbx,
    aesd,
    aese,
    aesimc,
    aesmc,
    dup,
    smov,
    umov,
    mov,
    sha1c,
    sha1h,
    sha1m,
    sha1p,
    sha1su0,
    sha1su1,
    sha256h,
    sha256h2,
    sha256su0,
    sha256su1,

    suqadd,
    sqabs,
    cmgt,
    cmeq,
    cmlt,
    abs,
    ext,
    sqxtn,
    sqxtn2,

    fcvtns,
    fcvtms,
    fcvtas,
    scvtf,
    fcmgt,
    fcmeq,
    fcmlt,
    fcvtps,
    fcvtzs,
    frecpe,
    frecpx,
    usqadd,
    sqneg,
    cmge,
    cmle,
    neg,
    sqxtun,
    sqxtun2,
    uqxtn,
    uqxtn2,
    fcvtxn,
    fcvtxn2,
    fcvtnu,
    fcvtmu,
    fcvtau,
    ucvtf,
    fcmge,
    fcmle,
    fcvtpu,
    fcvtzu,
    frsqrte,

    addp,
    fmaxnmp,
    faddp,
    fmaxp,
    fminnmp,
    fminp,

    sqdmlal,
    sqdmlsl,
    sqdmull,
    sqadd,
    sqsub,
    sshl,
    sqshl,
    srshl,
    sqrshl,
    add,
    cmtst,
    sqdmulh,
    fmulx,
    frecps,
    frsqrts,
    uqadd,
    uqsub,
    cmhi,
    cmhs,
    ushl,
    uqshl,
    urshl,
    uqrshl,
    sub,
    sqrdmulh,
    facge,
    fabd,
    facgt,

    sshr,
    ssra,
    srshr,
    srsra,
    shl,
    sqshrn,
    sqrshrn,

    ushr,
    usra,
    urshr,
    ursra,
    sri,
    sli,

    sqshlu,
    sqshrun,
    sqrshrun,
    uqshrn,
    uqrshrn,
    fmla,
    fmls,
    fmul,
}

#[derive(Debug, Clone, Copy)]
pub enum Mnemonic {
    adc,
    adcs,
    add,
    adds,
    adr,
    adrp,
    and,
    ands,
    asr,
    at,
    b,
    bfi,
    bfm,
    bfxil,
    bic,
    bics,
    bl,
    blr,
    br,
    brk,
    cbnz,
    cbz,
    ccmn,
    ccmp,
    cinc,
    cinv,
    clrex,
    cls,
    clz,
    cmn,
    cmp,
    cneg,
    crc32b,
    crc32cb,
    crc32ch,
    crc32cw,
    crc32cx,
    crc32h,
    crc32w,
    crc32x,
    csel,
    cset,
    csetm,
    csinc,
    csinv,
    csneg,
    dc,
    dcps1,
    dcps2,
    dcps3,
    dmb,
    drps,
    dsb,
    eon,
    eor,
    eret,
    extr,
    hint,
    hlt,
    hvc,
    ic,
    isb,
    ld1,
    ld1r,
    ld2,
    ld2r,
    ld3,
    ld3r,
    ld4,
    ld4r,
    ldar,
    ldarb,
    ldarh,
    ldaxp,
    ldaxr,
    ldaxrb,
    ldaxrh,
    ldnp,
    ldp,
    ldr,
    ldrb,
    ldrh,
    ldrsb,
    ldrsh,
    ldrsw,
    ldtr,
    ldtrb,
    ldtrh,
    ldtrsb,
    ldtrsh,
    ldtrsw,
    ldur,
    ldurb,
    ldurh,
    ldursb,
    ldursh,
    ldursw,
    ldxp,
    ldxr,
    ldxrb,
    ldxrh,
    lsl,
    lsr,
    madd,
    mneg,
    mov,
    movk,
    movn,
    movz,
    mrs,
    msr,
    msub,
    mul,
    mvn,
    neg,
    negs,
    ngc,
    ngcs,
    nop,
    orn,
    orr,
    prfm,
    prfum,
    rbit,
    ret,
    rev,
    rev16,
    rev32,
    ror,
    sbc,
    sbcs,
    sbfiz,
    sbfm,
    sbfx,
    sev,
    sevl,
    sdiv,
    smaddl,
    smc,
    smnegl,
    smsubl,
    smulh,
    smull,
    st1,
    st2,
    st3,
    st4,
    stlr,
    stlrb,
    stlrh,
    stlxp,
    stlxr,
    stlxrb,
    stlxrh,
    stnp,
    stp,
    str,
    strb,
    strh,
    sttr,
    sttrb,
    sttrh,
    stur,
    sturb,
    sturh,
    stxp,
    stxr,
    stxrb,
    stxrh,
    sub,
    subs,
    svc,
    sxtb,
    sxth,
    sxtw,
    sys,
    sysl,
    tbnz,
    tbz,
    tlbi,
    tst,
    ubfiz,
    ubfm,
    ubfx,
    udf,
    udiv,
    umaddl,
    umnegl,
    umsubl,
    umull,
    umulh,
    uxtb,
    uxth,
    wfe,
    wfi,
    yield_,
    Simd(SimdMnemonic),
    CondB(BranchCondition),
}

impl fmt::Display for Mnemonic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::CondB(br) => f.write_fmt(format_args!("b.{:?}", br)),
            Self::Simd(simd) => fmt::Debug::fmt(simd, f),
            Self::yield_ => f.write_str("yield"),
            _ => fmt::Debug::fmt(self, f),
        }
    }
}
